#Code modified from https://github.com/octopize/avatar-paper

from numpy import bool_
from numpy.typing import NDArray
import pandas as pd
from saiph.projection import fit_transform
from saiph.projection import transform
from numpy.typing import NDArray
import numpy as np
import pandas as pd
from numpy.typing import NDArray
from sklearn.neighbors import NearestNeighbors
import math
from typing import Tuple, Union

import faiss
import numpy as np
from numpy.typing import NDArray

# docs Python: https://github.com/facebookresearch/faiss/wiki/Getting-started

from copy import deepcopy
def calculate_metric(args, _real_data, _synthetic):
    real_data = _real_data.fillna(0)
    synthetic = _synthetic.fillna(0)

    coord_real, model = fit_transform(real_data, nf=2)
    coord_synth = transform(synthetic, model)

    are_first_hit = avatars_are_k_hit(
            coord_real, coord_synth, distance_metric="minkowski", k=1
        )
    
    results = calc_hidden_rate(are_first_hit)

    return results

class FaissKNeighbors:
    index: Union[faiss.IndexFlatL2, faiss.IndexIVFFlat]

    def __init__(self, k: int = 5) -> None:
        self.index = faiss.IndexFlatL2()
        self.k = k

    def fit(self, X: NDArray[np.float_]) -> None:
        xb: NDArray[np.float_] = X.astype(np.float32)
        size, dimension = X.shape
        nlist = round(math.sqrt(size))
        threshold_size = 50000

        # Use Index for large size dataframe
        if size > threshold_size:
            quantizer = faiss.IndexFlatL2(dimension)
            self.index = faiss.IndexIVFFlat(
                quantizer, dimension, nlist, faiss.METRIC_L2
            )
            assert self.index is not None  # nosec: B101
            self.index.train(xb)

        # perform exhaustive search otherwise
        else:
            self.index = faiss.IndexFlatL2(dimension)

        assert self.index is not None  # nosec: B101
        self.index.add(xb)

    def predict(
        self, X: NDArray[np.float_]
    ) -> Tuple[NDArray[np.float_], NDArray[np.int_]]:
        assert self.index is not None  # nosec: B101
        distances, indices = self.index.search(X.astype(np.float32), k=self.k)
        distances = np.sqrt(distances)
        return distances, indices


def calc_hidden_rate(are_first_hit: NDArray[bool_]) -> float:
    """Test for each record if the nearest avatar is the one generated by the original record itself.

    Arguments:
        are_first_hit: whether the nearest neighbor of the supplied
          original record is the avatar created from this record

    Returns:
        float: the percentage of records that could be considered "safe"
    """
    res: float = (are_first_hit.sum() / len(are_first_hit))
    return res


def avatars_are_k_hit(
    records_coordinates: pd.DataFrame,
    avatars_coordinates: pd.DataFrame,
    distance_metric: str = "minkowski",
    k: int = 1,
) -> NDArray[np.bool_]:
    """Test for each record if the nearest avatar is the one generated by the original record itself.

    Arguments:
        records_coordinates
        avatars_coordinates
        distance_metric
        k

    Returns:
        array: whether the nearest neighbor of the supplied original
          record is the avatar created from this record
    """
    if distance_metric not in [
        "cityblock",
        "cosine",
        "euclidean",
        "l1",
        "l2",
        "manhattan",
        "braycurtis",
        "canberra",
        "chebyshev",
        "correlation",
        "dice",
        "hamming",
        "jaccard",
        "kulsinski",
        "mahalanobis",
        "minkowski",
        "rogerstanimoto",
        "russellrao",
        "seuclidean",
        "sokalmichener",
        "sokalsneath",
        "sqeuclidean",
        "yule",
    ]:
        raise ValueError("distance_metric", "invalid distance metric")

    #if records_coordinates.shape[0] != avatars_coordinates.shape[0]:
    #    raise ValueError(
    #        "dimension",
    #        "Records set and synthetic set dataframes must have the same number of observations",
    #    )

    if distance_metric == "minkowski":
        nn = FaissKNeighbors(k=k)
        nn.fit(np.array(avatars_coordinates))
        distances, indices = nn.predict(np.array(records_coordinates))
    else:
        nn = NearestNeighbors(
            n_neighbors=1, algorithm="ball_tree", metric=distance_metric
        )
        nn.fit(avatars_coordinates)
        distances, indices = nn.kneighbors(records_coordinates)  # type: ignore

    indices_array: NDArray[np.int_] = np.array([item[0] for item in indices])

    are_k_hit: NDArray[np.bool_] = np.equal(
        indices_array, range(0, records_coordinates.shape[0])
    )

    return are_k_hit


